---
layout: post
title: 闭包
date: 2012-07-08
excerpt: "闭包有关概念的整理"
tags: [闭包, 原型, 原型链, 作用域, 作用域链, 执行上下文, this]
comments: true
---
<style type="text/css">
	*{
	font-family:"幼圆";
	font-weight:bold;	
}
	h2{
	color:#000;
	background-color:#1CA366;
}
	em{
	color:red;
}
</style>
## 原型

prototype

## 隐式原型

\_proto\_

*<font color=red>每个对象都有一个__proto__属性，指向创建该对象的函数的prototype</font>*

## A Instance of B

Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。
Instanceof的*判断规则*是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false
instanceof表示的就是一种<em>继承</em>关系，或者原型链的结构。

## 原型链

区分一个属性到底是基本的还是从原型中找到的

## 执行上下文（执行上下文环境）

函数每被调用一次，都会产生一个新的执行上下文环境，为执行做一些准备工作，
全局代码的上下文环境数据内容为：

| 数据内容 | 声明/赋值 |
| ----------- | ----------- |
| 普通变量（包括函数表达式），如： var a = 10； | 声明（默认赋值为undefined） |
| 函数声明，如： function fn() { } | 赋值 |
| this | 赋值 |
{: rules="groups"}

如果代码段是函数体，那么在此基础上需要附加：

| 数据内容 | 声明/赋值 |
| ----------- | ----------- |
| 参数 | 赋值 |
| arguments | 赋值 |
| 自由变量的取值作用域 | 赋值 |
{: rules="groups"}

*给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。*

## this

在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。

This的取值分5种情况。详见：[http://www.cnblogs.com/wangfupeng1988/p/3988422.html](http://www.cnblogs.com/wangfupeng1988/p/3988422.html)

* 构造函数
* 函数作为对象的一个属性
* 函数用call（）和apply（）调用
* 全局&调用普通函数
* 构造函数的prototype中

## 作用域

* javascript除了全局作用域之外，只有函数可以创建作用域
* 作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

*作用域与上下文执行环境的关系：作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。*

## 自由变量

在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。取自由变量x的值时，要到<font color=red>**创建（不是调用！！）**</font>A这个函数的那个作用域中取。

## 作用域链

一步步跨作用域找*自由变量*的路线叫做作用域链。

## 闭包

概念记不清，只记得应用。

* 返回函数
* 函数作为参数被传递

### 理解闭包的核心内容：其执行上下文环境不会被销毁
```javascript
funtion fn(){
	var max = 10;
	
	return function bar(x){
		if(x>max){
			console.log(x);
		}
	}
    }
    
var f1 = fn();
f1(15); 
```
   
因为fn（）返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。
因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。

### 闭包的用途

一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

### 闭包的注意事项

1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性(private value)这时一定要小心，不要随便改变父函数内部变量的值。
